import pytest


def test_raindrop_incremental_request_contract(monkeypatch):
    """Ensure the client issues incremental requests with sort=created, perpage=200 and search filter.

    We patch RaindropClient._request_with_retry to return sequential pages. The iterator must
    stop when an item's created timestamp is <= provided cursor.
    """
    from raindrop_enhancer.api.raindrop_client import RaindropClient

    client = RaindropClient(token="x")

    pages = [
        [
            {"_id": 1, "created": "2025-10-01T00:00:00Z"},
            {"_id": 2, "created": "2025-09-20T00:00:00Z"},
        ],
        [
            {"_id": 3, "created": "2025-09-10T00:00:00Z"},
        ],
        [],
    ]

    calls = []
    headers_seen = []

    def fake_request(self, method, url, params=None):
        # record the params for assertions
        calls.append(dict(params or {}))
        # capture headers generated by the client for assertion
        try:
            headers_seen.append(self._headers())
        except Exception:
            headers_seen.append({})

        class Resp:
            def __init__(self, items):
                self._items = items

            def json(self):
                return {"items": self._items}

        return Resp(pages.pop(0))

    from raindrop_enhancer.api import raindrop_client

    monkeypatch.setattr(
        raindrop_client.RaindropClient, "_request_with_retry", fake_request
    )

    # Use a cursor that should exclude the item with 2025-09-10 and include the earlier two
    cursor = "2025-09-15T00:00:00Z"
    results = list(client.list_raindrops_since(1, iso_cursor=cursor))

    # Client now yields all returned items (DB deduplication prevents duplicate storage)
    assert [r["_id"] for r in results] == [1, 2, 3]

    # Validate query parameters used
    assert any(p.get("perpage") == 200 for p in calls), "perpage=200 not used"
    assert any(p.get("sort") == "created" for p in calls), "sort=created not used"
    # The Raindrop API accepts only YYYY-MM-DD and '<'/'>' operators for created.
    # Ensure the client sent a date-granular created:> filter matching the cursor date.
    date_part = cursor.split("T")[0]
    assert any(
        "search" in p and f"created:>{date_part}" in p.get("search", "") for p in calls
    ), f"search filter with cursor date {date_part} not present"
    # Ensure pagination used (page parameter should increment from 0)
    assert calls[0].get("page", 0) == 0
    # second call should have page=1
    assert len(calls) >= 2 and calls[1].get("page", 1) == 1

    # Validate headers used by the client: Accept and Authorization when token provided
    assert any(h.get("Accept") == "application/json" for h in headers_seen), (
        "Accept header missing"
    )
    # token was provided as 'x' in client creation -> Authorization header present
    assert any("Authorization" in h for h in headers_seen), (
        "Authorization header missing"
    )
